# 4.29-

## todo

- 实现新增指令
DIV DIVU MULTU
BLTZAL BGEZAL
- 乘除法调用IP核
- 自己实现乘除法器 乘法采用 booth 算法+华莱士、除法采用迭代算法
- 通过lab3-3

## done

- 数据相关采取前递处理
- 计组实验实现的指令
MULT, MFLO, MFHI, MTLO, MTHI
BGEZ, BGTZ, BLTZ, BLEZ, JALR
- 能检测到未完成的指令,功能为能实现

- 根据之前的代码实现了 MULTU(未给出无符号信号)
  BLTZAL,BGEZAL(未验证)

## problem

## thinking

- 计组实现的指令需要看懂
- 乘法器部分需要看懂  
- 需要区别有符号乘法和无符号乘法,未给出能进行识别的信号
- 除法先参考计组书来实现
- JAL !!!
无论转移与否,将该分支对应延
迟槽指令之后的指令的 PC 值保存至第 31 号通用寄存器中
- **修改了ID_EXE总线,需要注意宽度一致性**

## tips

- **!!!切记指令译码不要写错,否则debug需要花费大量时间**

## debug

```c
--------------------------------------------------------------
[1967795 ns] Error!!!
    reference: PC = 0xbfc3f080, wb_rf_wnum = 0x1f, wb_rf_wdata = 0xbfc3f088
    mycpu    : PC = 0xbfc3f088, wb_rf_wnum = 0x04, wb_rf_wdata = 0xbfc00648
--------------------------------------------------------------
```

## reference

### BLTZAL

如果寄存器 rs 的值小于 0 则转移,否则顺序执行。转移目标由立即数 offset 左移 2 位并进行有符号
扩展的值加上该分支指令对应的延迟槽指令的 PC 计算得到。无论转移与否,将该分支对应延迟槽
指令之后的指令的 PC 值保存至第 31 号通用寄存器中。

### BGEZAL

如果寄存器 rs 的值大于等于 0 则转移,否则顺序执行。转移目标由立即数 offset 左移 2 位并进行有
符号扩展的值加上该分支指令对应的延迟槽指令的 PC 计算得到。无论转移与否,将该分支对应延
迟槽指令之后的指令的 PC 值保存至第 31 号通用寄存器中。